============================= test session starts ==============================
platform linux -- Python 3.8.16, pytest-7.3.2, pluggy-1.0.0 -- /home/yunwei/libebpf/test/bin/python3.8
cachedir: .pytest_cache
rootdir: /home/yunwei/libebpf
collecting ... collected 785 items

test/test_framework/test_assembler.py::test_datafiles[add.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[add64.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[alu-arith.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[alu-bit.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[alu.data] PASSED
test/test_framework/test_assembler.py::test_datafiles[alu64-arith.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[alu64-bit.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[alu64.data] PASSED
test/test_framework/test_assembler.py::test_datafiles[arsh-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[arsh.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[arsh32-high-shift.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[arsh64.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[be16-high.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[be16.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[be32-high.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[be32.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[be64.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[call-memfrob.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[call-save.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[call.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[call_unwind.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[call_unwind_fail.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div-by-zero-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div-by-zero-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div32-high-divisor.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div32-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div32-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div64-by-zero-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div64-by-zero-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div64-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div64-negative-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div64-negative-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[div64-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[early-exit.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-rel-offset.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-rel-strtab-index.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-rel-symbol-index.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-rel-symbol-name.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-rel-symbol-table-section-index.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-rel-type.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-section-header-offset.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-section-header-size.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-section-offset.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/bad-section-size.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/ehdr-short.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/no-text-section.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/ok.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/rel-sym-not-found.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/too-many-sections.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/wrong-byte-order.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/wrong-class.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/wrong-machine.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/wrong-osabi.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/wrong-type.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[elf/wrong-version.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-call-bad-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-call-unreg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-endian-size.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-incomplete-lddw.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-incomplete-lddw2.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-infinite-loop.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-invalid-reg-dst.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-invalid-reg-src.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-jmp-lddw.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-jmp-out.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-lddw-invalid-src.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-stack-oob.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-too-many-instructions.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[err-unknown-opcode.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[exit-not-last.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[exit.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ja.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jeq-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jeq-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jge-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jgt-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jgt-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jit-bounce.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jle-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jle-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jlt-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jlt-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jmp.data] PASSED
test/test_framework/test_assembler.py::test_datafiles[jne-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jset-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jset-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jsge-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jsge-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jsgt-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jsgt-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jsle-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jsle-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jslt-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[jslt-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[lddw.data] PASSED
test/test_framework/test_assembler.py::test_datafiles[lddw2.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ldx.data] PASSED
test/test_framework/test_assembler.py::test_datafiles[ldxb-all.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ldxb.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ldxdw.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ldxh-all.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ldxh-all2.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ldxh-same-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ldxh.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ldxw-all.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[ldxw.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[le16.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[le32.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[le64.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[lsh-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mem-len.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mod-by-zero-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mod-by-zero-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mod.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mod32.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mod64-by-zero-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mod64-by-zero-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mod64.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mov.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mov64-sign-extend.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mul-loop.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mul32-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mul32-reg-overflow.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mul32-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mul64-imm.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[mul64-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[neg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[neg64.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[prime.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[reload.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[rsh-reg.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[rsh32.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[st.data] PASSED
test/test_framework/test_assembler.py::test_datafiles[stack.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stack2.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stack3.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stb.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stdw.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[sth.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[string-stack.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stw.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stx.data] PASSED
test/test_framework/test_assembler.py::test_datafiles[stxb-all.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stxb-all2.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stxb-chain.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stxb.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stxdw.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stxh.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[stxw.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[subnet.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[tcp-port-80/match.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[tcp-port-80/nomatch-ethertype.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[tcp-port-80/nomatch-proto.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[tcp-port-80/nomatch.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[tcp-sack/match.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[tcp-sack/nomatch.data] SKIPPED
test/test_framework/test_assembler.py::test_datafiles[unload_reload.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[add.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[add64.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[alu-arith.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[alu-bit.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[alu.data] PASSED
test/test_framework/test_disassembler.py::test_datafiles[alu64-arith.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[alu64-bit.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[alu64.data] PASSED
test/test_framework/test_disassembler.py::test_datafiles[arsh-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[arsh.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[arsh32-high-shift.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[arsh64.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[be16-high.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[be16.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[be32-high.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[be32.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[be64.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[call-memfrob.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[call-save.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[call.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[call_unwind.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[call_unwind_fail.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div-by-zero-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div-by-zero-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div32-high-divisor.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div32-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div32-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div64-by-zero-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div64-by-zero-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div64-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div64-negative-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div64-negative-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[div64-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[early-exit.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-rel-offset.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-rel-strtab-index.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-rel-symbol-index.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-rel-symbol-name.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-rel-symbol-table-section-index.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-rel-type.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-section-header-offset.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-section-header-size.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-section-offset.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/bad-section-size.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/ehdr-short.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/no-text-section.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/ok.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/rel-sym-not-found.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/too-many-sections.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/wrong-byte-order.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/wrong-class.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/wrong-machine.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/wrong-osabi.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/wrong-type.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[elf/wrong-version.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-call-bad-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-call-unreg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-endian-size.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-incomplete-lddw.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-incomplete-lddw2.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-infinite-loop.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-invalid-reg-dst.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-invalid-reg-src.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-jmp-lddw.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-jmp-out.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-lddw-invalid-src.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-stack-oob.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-too-many-instructions.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[err-unknown-opcode.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[exit-not-last.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[exit.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ja.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jeq-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jeq-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jge-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jgt-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jgt-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jit-bounce.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jle-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jle-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jlt-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jlt-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jmp.data] PASSED
test/test_framework/test_disassembler.py::test_datafiles[jne-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jset-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jset-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jsge-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jsge-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jsgt-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jsgt-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jsle-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jsle-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jslt-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[jslt-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[lddw.data] PASSED
test/test_framework/test_disassembler.py::test_datafiles[lddw2.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ldx.data] PASSED
test/test_framework/test_disassembler.py::test_datafiles[ldxb-all.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ldxb.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ldxdw.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ldxh-all.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ldxh-all2.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ldxh-same-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ldxh.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ldxw-all.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[ldxw.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[le16.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[le32.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[le64.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[lsh-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mem-len.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mod-by-zero-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mod-by-zero-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mod.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mod32.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mod64-by-zero-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mod64-by-zero-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mod64.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mov.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mov64-sign-extend.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mul-loop.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mul32-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mul32-reg-overflow.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mul32-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mul64-imm.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[mul64-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[neg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[neg64.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[prime.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[reload.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[rsh-reg.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[rsh32.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[st.data] PASSED
test/test_framework/test_disassembler.py::test_datafiles[stack.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stack2.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stack3.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stb.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stdw.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[sth.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[string-stack.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stw.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stx.data] PASSED
test/test_framework/test_disassembler.py::test_datafiles[stxb-all.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stxb-all2.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stxb-chain.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stxb.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stxdw.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stxh.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[stxw.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[subnet.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[tcp-port-80/match.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[tcp-port-80/nomatch-ethertype.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[tcp-port-80/nomatch-proto.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[tcp-port-80/nomatch.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[tcp-sack/match.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[tcp-sack/nomatch.data] SKIPPED
test/test_framework/test_disassembler.py::test_datafiles[unload_reload.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[add.data] FAILED
test/test_framework/test_jit.py::test_datafiles[add64.data] FAILED
test/test_framework/test_jit.py::test_datafiles[alu-arith.data] FAILED
test/test_framework/test_jit.py::test_datafiles[alu-bit.data] FAILED
test/test_framework/test_jit.py::test_datafiles[alu.data] SKIPPED (n...)
test/test_framework/test_jit.py::test_datafiles[alu64-arith.data] FAILED
test/test_framework/test_jit.py::test_datafiles[alu64-bit.data] FAILED
test/test_framework/test_jit.py::test_datafiles[alu64.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[arsh-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[arsh.data] FAILED
test/test_framework/test_jit.py::test_datafiles[arsh32-high-shift.data] FAILED
test/test_framework/test_jit.py::test_datafiles[arsh64.data] FAILED
test/test_framework/test_jit.py::test_datafiles[be16-high.data] FAILED
test/test_framework/test_jit.py::test_datafiles[be16.data] FAILED
test/test_framework/test_jit.py::test_datafiles[be32-high.data] FAILED
test/test_framework/test_jit.py::test_datafiles[be32.data] FAILED
test/test_framework/test_jit.py::test_datafiles[be64.data] FAILED
test/test_framework/test_jit.py::test_datafiles[call-memfrob.data] FAILED
test/test_framework/test_jit.py::test_datafiles[call-save.data] FAILED
test/test_framework/test_jit.py::test_datafiles[call.data] FAILED
test/test_framework/test_jit.py::test_datafiles[call_unwind.data] FAILED
test/test_framework/test_jit.py::test_datafiles[call_unwind_fail.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div-by-zero-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div-by-zero-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div32-high-divisor.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div32-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div32-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div64-by-zero-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div64-by-zero-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div64-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div64-negative-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div64-negative-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[div64-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[early-exit.data] FAILED
test/test_framework/test_jit.py::test_datafiles[elf/bad-rel-offset.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/bad-rel-strtab-index.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/bad-rel-symbol-index.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/bad-rel-symbol-name.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/bad-rel-symbol-table-section-index.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/bad-rel-type.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/bad-section-header-offset.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/bad-section-header-size.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/bad-section-offset.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/bad-section-size.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/ehdr-short.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/no-text-section.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/ok.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/rel-sym-not-found.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/too-many-sections.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/wrong-byte-order.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/wrong-class.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/wrong-machine.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/wrong-osabi.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/wrong-type.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[elf/wrong-version.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[err-call-bad-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-call-unreg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-endian-size.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-incomplete-lddw.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-incomplete-lddw2.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-infinite-loop.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-invalid-reg-dst.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-invalid-reg-src.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-jmp-lddw.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-jmp-out.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-lddw-invalid-src.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-stack-oob.data] SKIPPED
test/test_framework/test_jit.py::test_datafiles[err-too-many-instructions.data] FAILED
test/test_framework/test_jit.py::test_datafiles[err-unknown-opcode.data] FAILED
test/test_framework/test_jit.py::test_datafiles[exit-not-last.data] FAILED
test/test_framework/test_jit.py::test_datafiles[exit.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ja.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jeq-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jeq-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jge-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jgt-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jgt-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jit-bounce.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jle-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jle-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jlt-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jlt-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jmp.data] SKIPPED (n...)
test/test_framework/test_jit.py::test_datafiles[jne-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jset-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jset-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jsge-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jsge-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jsgt-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jsgt-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jsle-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jsle-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jslt-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[jslt-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[lddw.data] FAILED
test/test_framework/test_jit.py::test_datafiles[lddw2.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ldx.data] SKIPPED (n...)
test/test_framework/test_jit.py::test_datafiles[ldxb-all.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ldxb.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ldxdw.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ldxh-all.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ldxh-all2.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ldxh-same-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ldxh.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ldxw-all.data] FAILED
test/test_framework/test_jit.py::test_datafiles[ldxw.data] FAILED
test/test_framework/test_jit.py::test_datafiles[le16.data] FAILED
test/test_framework/test_jit.py::test_datafiles[le32.data] FAILED
test/test_framework/test_jit.py::test_datafiles[le64.data] FAILED
test/test_framework/test_jit.py::test_datafiles[lsh-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mem-len.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mod-by-zero-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mod-by-zero-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mod.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mod32.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mod64-by-zero-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mod64-by-zero-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mod64.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mov.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mov64-sign-extend.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mul-loop.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mul32-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mul32-reg-overflow.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mul32-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mul64-imm.data] FAILED
test/test_framework/test_jit.py::test_datafiles[mul64-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[neg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[neg64.data] FAILED
test/test_framework/test_jit.py::test_datafiles[prime.data] FAILED
test/test_framework/test_jit.py::test_datafiles[reload.data] FAILED
test/test_framework/test_jit.py::test_datafiles[rsh-reg.data] FAILED
test/test_framework/test_jit.py::test_datafiles[rsh32.data] FAILED
test/test_framework/test_jit.py::test_datafiles[st.data] SKIPPED (no...)
test/test_framework/test_jit.py::test_datafiles[stack.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stack2.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stack3.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stb.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stdw.data] FAILED
test/test_framework/test_jit.py::test_datafiles[sth.data] FAILED
test/test_framework/test_jit.py::test_datafiles[string-stack.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stw.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stx.data] SKIPPED (n...)
test/test_framework/test_jit.py::test_datafiles[stxb-all.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stxb-all2.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stxb-chain.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stxb.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stxdw.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stxh.data] FAILED
test/test_framework/test_jit.py::test_datafiles[stxw.data] FAILED
test/test_framework/test_jit.py::test_datafiles[subnet.data] FAILED
test/test_framework/test_jit.py::test_datafiles[tcp-port-80/match.data] FAILED
test/test_framework/test_jit.py::test_datafiles[tcp-port-80/nomatch-ethertype.data] FAILED
test/test_framework/test_jit.py::test_datafiles[tcp-port-80/nomatch-proto.data] FAILED
test/test_framework/test_jit.py::test_datafiles[tcp-port-80/nomatch.data] FAILED
test/test_framework/test_jit.py::test_datafiles[tcp-sack/match.data] FAILED
test/test_framework/test_jit.py::test_datafiles[tcp-sack/nomatch.data] FAILED
test/test_framework/test_jit.py::test_datafiles[unload_reload.data] FAILED
test/test_framework/test_roundtrip.py::test_datafiles[add.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[add64.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[alu-arith.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[alu-bit.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[alu.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[alu64-arith.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[alu64-bit.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[alu64.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[arsh-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[arsh.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[arsh32-high-shift.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[arsh64.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[be16-high.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[be16.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[be32-high.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[be32.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[be64.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[call-memfrob.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[call-save.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[call.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[call_unwind.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[call_unwind_fail.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div-by-zero-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div-by-zero-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div32-high-divisor.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div32-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div32-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div64-by-zero-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div64-by-zero-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div64-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div64-negative-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div64-negative-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[div64-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[early-exit.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-rel-offset.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-rel-strtab-index.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-rel-symbol-index.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-rel-symbol-name.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-rel-symbol-table-section-index.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-rel-type.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-section-header-offset.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-section-header-size.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-section-offset.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/bad-section-size.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/ehdr-short.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/no-text-section.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/ok.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/rel-sym-not-found.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/too-many-sections.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/wrong-byte-order.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/wrong-class.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/wrong-machine.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/wrong-osabi.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/wrong-type.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[elf/wrong-version.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[err-call-bad-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[err-call-unreg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[err-endian-size.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[err-incomplete-lddw.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[err-incomplete-lddw2.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[err-infinite-loop.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[err-invalid-reg-dst.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[err-invalid-reg-src.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[err-jmp-lddw.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[err-jmp-out.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[err-lddw-invalid-src.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[err-stack-oob.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[err-too-many-instructions.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[err-unknown-opcode.data] SKIPPED
test/test_framework/test_roundtrip.py::test_datafiles[exit-not-last.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[exit.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ja.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jeq-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jeq-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jge-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jgt-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jgt-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jit-bounce.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jle-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jle-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jlt-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jlt-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jmp.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jne-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jset-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jset-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jsge-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jsge-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jsgt-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jsgt-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jsle-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jsle-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jslt-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[jslt-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[lddw.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[lddw2.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldx.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldxb-all.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldxb.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldxdw.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldxh-all.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldxh-all2.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldxh-same-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldxh.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldxw-all.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[ldxw.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[le16.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[le32.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[le64.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[lsh-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mem-len.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mod-by-zero-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mod-by-zero-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mod.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mod32.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mod64-by-zero-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mod64-by-zero-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mod64.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mov.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mov64-sign-extend.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mul-loop.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mul32-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mul32-reg-overflow.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mul32-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mul64-imm.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[mul64-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[neg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[neg64.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[prime.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[reload.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[rsh-reg.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[rsh32.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[st.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stack.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stack2.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stack3.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stb.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stdw.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[sth.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[string-stack.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stw.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stx.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stxb-all.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stxb-all2.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stxb-chain.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stxb.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stxdw.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stxh.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[stxw.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[subnet.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[tcp-port-80/match.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[tcp-port-80/nomatch-ethertype.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[tcp-port-80/nomatch-proto.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[tcp-port-80/nomatch.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[tcp-sack/match.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[tcp-sack/nomatch.data] PASSED
test/test_framework/test_roundtrip.py::test_datafiles[unload_reload.data] PASSED
test/test_framework/test_vm.py::test_datafiles[add.data] FAILED
test/test_framework/test_vm.py::test_datafiles[add64.data] FAILED
test/test_framework/test_vm.py::test_datafiles[alu-arith.data] FAILED
test/test_framework/test_vm.py::test_datafiles[alu-bit.data] FAILED
test/test_framework/test_vm.py::test_datafiles[alu.data] SKIPPED (no...)
test/test_framework/test_vm.py::test_datafiles[alu64-arith.data] FAILED
test/test_framework/test_vm.py::test_datafiles[alu64-bit.data] FAILED
test/test_framework/test_vm.py::test_datafiles[alu64.data] SKIPPED (...)
test/test_framework/test_vm.py::test_datafiles[arsh-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[arsh.data] FAILED
test/test_framework/test_vm.py::test_datafiles[arsh32-high-shift.data] FAILED
test/test_framework/test_vm.py::test_datafiles[arsh64.data] FAILED
test/test_framework/test_vm.py::test_datafiles[be16-high.data] FAILED
test/test_framework/test_vm.py::test_datafiles[be16.data] FAILED
test/test_framework/test_vm.py::test_datafiles[be32-high.data] FAILED
test/test_framework/test_vm.py::test_datafiles[be32.data] FAILED
test/test_framework/test_vm.py::test_datafiles[be64.data] FAILED
test/test_framework/test_vm.py::test_datafiles[call-memfrob.data] FAILED
test/test_framework/test_vm.py::test_datafiles[call-save.data] FAILED
test/test_framework/test_vm.py::test_datafiles[call.data] FAILED
test/test_framework/test_vm.py::test_datafiles[call_unwind.data] FAILED
test/test_framework/test_vm.py::test_datafiles[call_unwind_fail.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div-by-zero-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div-by-zero-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div32-high-divisor.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div32-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div32-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div64-by-zero-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div64-by-zero-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div64-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div64-negative-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div64-negative-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[div64-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[early-exit.data] FAILED
test/test_framework/test_vm.py::test_datafiles[elf/bad-rel-offset.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/bad-rel-strtab-index.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/bad-rel-symbol-index.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/bad-rel-symbol-name.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/bad-rel-symbol-table-section-index.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/bad-rel-type.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/bad-section-header-offset.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/bad-section-header-size.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/bad-section-offset.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/bad-section-size.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/ehdr-short.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/no-text-section.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/ok.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/rel-sym-not-found.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/too-many-sections.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/wrong-byte-order.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/wrong-class.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/wrong-machine.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/wrong-osabi.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/wrong-type.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[elf/wrong-version.data] SKIPPED
test/test_framework/test_vm.py::test_datafiles[err-call-bad-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-call-unreg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-endian-size.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-incomplete-lddw.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-incomplete-lddw2.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-infinite-loop.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-invalid-reg-dst.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-invalid-reg-src.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-jmp-lddw.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-jmp-out.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-lddw-invalid-src.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-stack-oob.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-too-many-instructions.data] FAILED
test/test_framework/test_vm.py::test_datafiles[err-unknown-opcode.data] FAILED
test/test_framework/test_vm.py::test_datafiles[exit-not-last.data] FAILED
test/test_framework/test_vm.py::test_datafiles[exit.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ja.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jeq-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jeq-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jge-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jgt-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jgt-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jit-bounce.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jle-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jle-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jlt-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jlt-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jmp.data] SKIPPED (no...)
test/test_framework/test_vm.py::test_datafiles[jne-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jset-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jset-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jsge-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jsge-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jsgt-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jsgt-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jsle-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jsle-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jslt-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[jslt-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[lddw.data] FAILED
test/test_framework/test_vm.py::test_datafiles[lddw2.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ldx.data] SKIPPED (no...)
test/test_framework/test_vm.py::test_datafiles[ldxb-all.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ldxb.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ldxdw.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ldxh-all.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ldxh-all2.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ldxh-same-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ldxh.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ldxw-all.data] FAILED
test/test_framework/test_vm.py::test_datafiles[ldxw.data] FAILED
test/test_framework/test_vm.py::test_datafiles[le16.data] FAILED
test/test_framework/test_vm.py::test_datafiles[le32.data] FAILED
test/test_framework/test_vm.py::test_datafiles[le64.data] FAILED
test/test_framework/test_vm.py::test_datafiles[lsh-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mem-len.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mod-by-zero-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mod-by-zero-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mod.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mod32.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mod64-by-zero-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mod64-by-zero-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mod64.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mov.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mov64-sign-extend.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mul-loop.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mul32-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mul32-reg-overflow.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mul32-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mul64-imm.data] FAILED
test/test_framework/test_vm.py::test_datafiles[mul64-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[neg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[neg64.data] FAILED
test/test_framework/test_vm.py::test_datafiles[prime.data] FAILED
test/test_framework/test_vm.py::test_datafiles[reload.data] FAILED
test/test_framework/test_vm.py::test_datafiles[rsh-reg.data] FAILED
test/test_framework/test_vm.py::test_datafiles[rsh32.data] FAILED
test/test_framework/test_vm.py::test_datafiles[st.data] SKIPPED (no ...)
test/test_framework/test_vm.py::test_datafiles[stack.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stack2.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stack3.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stb.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stdw.data] FAILED
test/test_framework/test_vm.py::test_datafiles[sth.data] FAILED
test/test_framework/test_vm.py::test_datafiles[string-stack.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stw.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stx.data] SKIPPED (no...)
test/test_framework/test_vm.py::test_datafiles[stxb-all.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stxb-all2.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stxb-chain.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stxb.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stxdw.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stxh.data] FAILED
test/test_framework/test_vm.py::test_datafiles[stxw.data] FAILED
test/test_framework/test_vm.py::test_datafiles[subnet.data] FAILED
test/test_framework/test_vm.py::test_datafiles[tcp-port-80/match.data] FAILED
test/test_framework/test_vm.py::test_datafiles[tcp-port-80/nomatch-ethertype.data] FAILED
test/test_framework/test_vm.py::test_datafiles[tcp-port-80/nomatch-proto.data] FAILED
test/test_framework/test_vm.py::test_datafiles[tcp-port-80/nomatch.data] FAILED
test/test_framework/test_vm.py::test_datafiles[tcp-sack/match.data] FAILED
test/test_framework/test_vm.py::test_datafiles[tcp-sack/nomatch.data] FAILED
test/test_framework/test_vm.py::test_datafiles[unload_reload.data] FAILED

=================================== FAILURES ===================================
___________________________ test_datafiles[add.data] ___________________________

filename = 'add.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'add.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[add64.data] __________________________

filename = 'add64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'add64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[alu-arith.data] ________________________

filename = 'alu-arith.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'alu-arith.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[alu-bit.data] _________________________

filename = 'alu-bit.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'alu-bit.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_______________________ test_datafiles[alu64-arith.data] _______________________

filename = 'alu64-arith.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'alu64-arith.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[alu64-bit.data] ________________________

filename = 'alu64-bit.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'alu64-bit.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[arsh-reg.data] _________________________

filename = 'arsh-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'arsh-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[arsh.data] ___________________________

filename = 'arsh.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'arsh.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[arsh32-high-shift.data] ____________________

filename = 'arsh32-high-shift.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'arsh32-high-shift.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[arsh64.data] __________________________

filename = 'arsh64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'arsh64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[be16-high.data] ________________________

filename = 'be16-high.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be16-high.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[be16.data] ___________________________

filename = 'be16.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be16.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[be32-high.data] ________________________

filename = 'be32-high.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be32-high.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[be32.data] ___________________________

filename = 'be32.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be32.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[be64.data] ___________________________

filename = 'be64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
______________________ test_datafiles[call-memfrob.data] _______________________

filename = 'call-memfrob.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call-memfrob.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[call-save.data] ________________________

filename = 'call-save.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call-save.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[call.data] ___________________________

filename = 'call.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_______________________ test_datafiles[call_unwind.data] _______________________

filename = 'call_unwind.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call_unwind.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[call_unwind_fail.data] _____________________

filename = 'call_unwind_fail.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call_unwind_fail.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_____________________ test_datafiles[div-by-zero-imm.data] _____________________

filename = 'div-by-zero-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div-by-zero-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_____________________ test_datafiles[div-by-zero-reg.data] _____________________

filename = 'div-by-zero-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div-by-zero-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________ test_datafiles[div32-high-divisor.data] ____________________

filename = 'div32-high-divisor.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div32-high-divisor.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[div32-imm.data] ________________________

filename = 'div32-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div32-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[div32-reg.data] ________________________

filename = 'div32-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div32-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[div64-by-zero-imm.data] ____________________

filename = 'div64-by-zero-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-by-zero-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[div64-by-zero-reg.data] ____________________

filename = 'div64-by-zero-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-by-zero-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[div64-imm.data] ________________________

filename = 'div64-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________ test_datafiles[div64-negative-imm.data] ____________________

filename = 'div64-negative-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-negative-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________ test_datafiles[div64-negative-reg.data] ____________________

filename = 'div64-negative-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-negative-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[div64-reg.data] ________________________

filename = 'div64-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_______________________ test_datafiles[early-exit.data] ________________________

filename = 'early-exit.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'early-exit.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[err-call-bad-imm.data] _____________________

filename = 'err-call-bad-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-call-bad-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: invalid call immediate at PC 5', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
_____________________ test_datafiles[err-call-unreg.data] ______________________

filename = 'err-call-unreg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-call-unreg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: call to nonexistent function 63 at PC 5', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
_____________________ test_datafiles[err-endian-size.data] _____________________

filename = 'err-endian-size.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-endian-size.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: invalid endian immediate at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
___________________ test_datafiles[err-incomplete-lddw.data] ___________________

filename = 'err-incomplete-lddw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-incomplete-lddw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: incomplete lddw at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
__________________ test_datafiles[err-incomplete-lddw2.data] ___________________

filename = 'err-incomplete-lddw2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-incomplete-lddw2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: incomplete lddw at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
____________________ test_datafiles[err-infinite-loop.data] ____________________

filename = 'err-infinite-loop.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-infinite-loop.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: infinite loop at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
___________________ test_datafiles[err-invalid-reg-dst.data] ___________________

filename = 'err-invalid-reg-dst.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-invalid-reg-dst.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: invalid destination register at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
___________________ test_datafiles[err-invalid-reg-src.data] ___________________

filename = 'err-invalid-reg-src.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-invalid-reg-src.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: invalid source register at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
______________________ test_datafiles[err-jmp-lddw.data] _______________________

filename = 'err-jmp-lddw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-jmp-lddw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: jump to middle of lddw at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
_______________________ test_datafiles[err-jmp-out.data] _______________________

filename = 'err-jmp-out.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-jmp-out.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: jump out of bounds at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
__________________ test_datafiles[err-lddw-invalid-src.data] ___________________

filename = 'err-lddw-invalid-src.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-lddw-invalid-src.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: invalid source register for LDDW at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
________________ test_datafiles[err-too-many-instructions.data] ________________

filename = 'err-too-many-instructions.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-too-many-instructions.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: too many instructions (max 65536)', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
___________________ test_datafiles[err-unknown-opcode.data] ____________________

filename = 'err-unknown-opcode.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-unknown-opcode.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: unknown opcode 0x06 at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
______________________ test_datafiles[exit-not-last.data] ______________________

filename = 'exit-not-last.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'exit-not-last.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[exit.data] ___________________________

filename = 'exit.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'exit.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________________ test_datafiles[ja.data] ____________________________

filename = 'ja.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ja.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jeq-imm.data] _________________________

filename = 'jeq-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jeq-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jeq-reg.data] _________________________

filename = 'jeq-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jeq-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jge-imm.data] _________________________

filename = 'jge-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jge-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jgt-imm.data] _________________________

filename = 'jgt-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jgt-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jgt-reg.data] _________________________

filename = 'jgt-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jgt-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_______________________ test_datafiles[jit-bounce.data] ________________________

filename = 'jit-bounce.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jit-bounce.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jle-imm.data] _________________________

filename = 'jle-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jle-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jle-reg.data] _________________________

filename = 'jle-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jle-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jlt-imm.data] _________________________

filename = 'jlt-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jlt-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jlt-reg.data] _________________________

filename = 'jlt-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jlt-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[jne-reg.data] _________________________

filename = 'jne-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jne-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jset-imm.data] _________________________

filename = 'jset-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jset-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jset-reg.data] _________________________

filename = 'jset-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jset-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jsge-imm.data] _________________________

filename = 'jsge-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsge-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jsge-reg.data] _________________________

filename = 'jsge-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsge-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jsgt-imm.data] _________________________

filename = 'jsgt-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsgt-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jsgt-reg.data] _________________________

filename = 'jsgt-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsgt-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jsle-imm.data] _________________________

filename = 'jsle-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsle-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jsle-reg.data] _________________________

filename = 'jsle-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsle-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jslt-imm.data] _________________________

filename = 'jslt-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jslt-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[jslt-reg.data] _________________________

filename = 'jslt-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jslt-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[lddw.data] ___________________________

filename = 'lddw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'lddw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[lddw2.data] __________________________

filename = 'lddw2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'lddw2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[ldxb-all.data] _________________________

filename = 'ldxb-all.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxb-all.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[ldxb.data] ___________________________

filename = 'ldxb.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxb.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[ldxdw.data] __________________________

filename = 'ldxdw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxdw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[ldxh-all.data] _________________________

filename = 'ldxh-all.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxh-all.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[ldxh-all2.data] ________________________

filename = 'ldxh-all2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxh-all2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
______________________ test_datafiles[ldxh-same-reg.data] ______________________

filename = 'ldxh-same-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxh-same-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[ldxh.data] ___________________________

filename = 'ldxh.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxh.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[ldxw-all.data] _________________________

filename = 'ldxw-all.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxw-all.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[ldxw.data] ___________________________

filename = 'ldxw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[le16.data] ___________________________

filename = 'le16.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'le16.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[le32.data] ___________________________

filename = 'le32.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'le32.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[le64.data] ___________________________

filename = 'le64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'le64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[lsh-reg.data] _________________________

filename = 'lsh-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'lsh-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[mem-len.data] _________________________

filename = 'mem-len.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mem-len.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_____________________ test_datafiles[mod-by-zero-imm.data] _____________________

filename = 'mod-by-zero-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod-by-zero-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_____________________ test_datafiles[mod-by-zero-reg.data] _____________________

filename = 'mod-by-zero-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod-by-zero-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________________ test_datafiles[mod.data] ___________________________

filename = 'mod.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[mod32.data] __________________________

filename = 'mod32.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod32.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[mod64-by-zero-imm.data] ____________________

filename = 'mod64-by-zero-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod64-by-zero-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[mod64-by-zero-reg.data] ____________________

filename = 'mod64-by-zero-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod64-by-zero-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[mod64.data] __________________________

filename = 'mod64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________________ test_datafiles[mov.data] ___________________________

filename = 'mov.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mov.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[mov64-sign-extend.data] ____________________

filename = 'mov64-sign-extend.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mov64-sign-extend.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[mul-loop.data] _________________________

filename = 'mul-loop.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul-loop.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[mul32-imm.data] ________________________

filename = 'mul32-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul32-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________ test_datafiles[mul32-reg-overflow.data] ____________________

filename = 'mul32-reg-overflow.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul32-reg-overflow.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[mul32-reg.data] ________________________

filename = 'mul32-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul32-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[mul64-imm.data] ________________________

filename = 'mul64-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul64-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[mul64-reg.data] ________________________

filename = 'mul64-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul64-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________________ test_datafiles[neg.data] ___________________________

filename = 'neg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'neg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[neg64.data] __________________________

filename = 'neg64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'neg64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[prime.data] __________________________

filename = 'prime.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'prime.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[reload.data] __________________________

filename = 'reload.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'reload.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
>                       raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E                       AssertionError: Expected error 'Failed to load code: code has already been loaded into this VM. Use ebpf_unload_code() if you need to reuse this VM', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:78: AssertionError
_________________________ test_datafiles[rsh-reg.data] _________________________

filename = 'rsh-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'rsh-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[rsh32.data] __________________________

filename = 'rsh32.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'rsh32.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[stack.data] __________________________

filename = 'stack.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stack.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[stack2.data] __________________________

filename = 'stack2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stack2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[stack3.data] __________________________

filename = 'stack3.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stack3.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________________ test_datafiles[stb.data] ___________________________

filename = 'stb.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stb.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[stdw.data] ___________________________

filename = 'stdw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stdw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________________ test_datafiles[sth.data] ___________________________

filename = 'sth.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'sth.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
______________________ test_datafiles[string-stack.data] _______________________

filename = 'string-stack.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'string-stack.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________________ test_datafiles[stw.data] ___________________________

filename = 'stw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[stxb-all.data] _________________________

filename = 'stxb-all.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxb-all.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________________ test_datafiles[stxb-all2.data] ________________________

filename = 'stxb-all2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxb-all2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_______________________ test_datafiles[stxb-chain.data] ________________________

filename = 'stxb-chain.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxb-chain.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[stxb.data] ___________________________

filename = 'stxb.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxb.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[stxdw.data] __________________________

filename = 'stxdw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxdw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[stxh.data] ___________________________

filename = 'stxh.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxh.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
__________________________ test_datafiles[stxw.data] ___________________________

filename = 'stxw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_________________________ test_datafiles[subnet.data] __________________________

filename = 'subnet.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'subnet.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[tcp-port-80/match.data] ____________________

filename = 'tcp-port-80/match.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-port-80/match.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
______________ test_datafiles[tcp-port-80/nomatch-ethertype.data] ______________

filename = 'tcp-port-80/nomatch-ethertype.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-port-80/nomatch-ethertype.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
________________ test_datafiles[tcp-port-80/nomatch-proto.data] ________________

filename = 'tcp-port-80/nomatch-proto.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-port-80/nomatch-proto.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________ test_datafiles[tcp-port-80/nomatch.data] ___________________

filename = 'tcp-port-80/nomatch.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-port-80/nomatch.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
_____________________ test_datafiles[tcp-sack/match.data] ______________________

filename = 'tcp-sack/match.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-sack/match.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
____________________ test_datafiles[tcp-sack/nomatch.data] _____________________

filename = 'tcp-sack/nomatch.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-sack/nomatch.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
______________________ test_datafiles[unload_reload.data] ______________________

filename = 'unload_reload.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_jit.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'unload_reload.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches. Uses the JIT compiler.
        """
        if not jit_supported_platform():
            raise SkipTest("JIT is not supported on the current platform")
    
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found")
        if 'no jit' in data:
            raise SkipTest("JIT disabled for this testcase (%s)" % data['no jit'])
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
    
        num_register_offsets = 20
        if 'no register offset' in data:
            # The JIT relies on a fixed register mapping for the call instruction
            num_register_offsets = 1
    
        try:
            for register_offset in xrange(0, num_register_offsets):
                cmd = [VM]
                if memfile:
                    cmd.extend(['-m', memfile.name])
                if 'reload' in data:
                    cmd.extend(['-R'])
                if 'unload' in data:
                    cmd.extend(['-U'])
                cmd.extend(['-j', '-r', str(register_offset), '-'])
    
                vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
                stdout, stderr = vm.communicate(code)
                stdout = stdout.decode("utf-8")
                stderr = stderr.decode("utf-8")
                stderr = stderr.strip()
    
                if 'error' in data:
                    if data['error'] != stderr:
                        raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
                elif 'error pattern' in data:
                    if not re.search(data['error pattern'], stderr):
                        raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
                else:
                    if stderr:
>                       raise AssertionError("Unexpected error %r" % stderr)
E                       AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_jit.py:84: AssertionError
___________________________ test_datafiles[add.data] ___________________________

filename = 'add.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'add.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[add64.data] __________________________

filename = 'add64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'add64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[alu-arith.data] ________________________

filename = 'alu-arith.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'alu-arith.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[alu-bit.data] _________________________

filename = 'alu-bit.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'alu-bit.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_______________________ test_datafiles[alu64-arith.data] _______________________

filename = 'alu64-arith.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'alu64-arith.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[alu64-bit.data] ________________________

filename = 'alu64-bit.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'alu64-bit.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[arsh-reg.data] _________________________

filename = 'arsh-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'arsh-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[arsh.data] ___________________________

filename = 'arsh.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'arsh.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[arsh32-high-shift.data] ____________________

filename = 'arsh32-high-shift.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'arsh32-high-shift.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[arsh64.data] __________________________

filename = 'arsh64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'arsh64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[be16-high.data] ________________________

filename = 'be16-high.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be16-high.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[be16.data] ___________________________

filename = 'be16.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be16.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[be32-high.data] ________________________

filename = 'be32-high.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be32-high.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[be32.data] ___________________________

filename = 'be32.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be32.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[be64.data] ___________________________

filename = 'be64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'be64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
______________________ test_datafiles[call-memfrob.data] _______________________

filename = 'call-memfrob.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call-memfrob.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[call-save.data] ________________________

filename = 'call-save.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call-save.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[call.data] ___________________________

filename = 'call.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_______________________ test_datafiles[call_unwind.data] _______________________

filename = 'call_unwind.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call_unwind.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[call_unwind_fail.data] _____________________

filename = 'call_unwind_fail.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'call_unwind_fail.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_____________________ test_datafiles[div-by-zero-imm.data] _____________________

filename = 'div-by-zero-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div-by-zero-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_____________________ test_datafiles[div-by-zero-reg.data] _____________________

filename = 'div-by-zero-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div-by-zero-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________ test_datafiles[div32-high-divisor.data] ____________________

filename = 'div32-high-divisor.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div32-high-divisor.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[div32-imm.data] ________________________

filename = 'div32-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div32-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[div32-reg.data] ________________________

filename = 'div32-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div32-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[div64-by-zero-imm.data] ____________________

filename = 'div64-by-zero-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-by-zero-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[div64-by-zero-reg.data] ____________________

filename = 'div64-by-zero-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-by-zero-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[div64-imm.data] ________________________

filename = 'div64-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________ test_datafiles[div64-negative-imm.data] ____________________

filename = 'div64-negative-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-negative-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________ test_datafiles[div64-negative-reg.data] ____________________

filename = 'div64-negative-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-negative-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[div64-reg.data] ________________________

filename = 'div64-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'div64-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_______________________ test_datafiles[early-exit.data] ________________________

filename = 'early-exit.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'early-exit.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[err-call-bad-imm.data] _____________________

filename = 'err-call-bad-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-call-bad-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: invalid call immediate at PC 5', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
_____________________ test_datafiles[err-call-unreg.data] ______________________

filename = 'err-call-unreg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-call-unreg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: call to nonexistent function 63 at PC 5', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
_____________________ test_datafiles[err-endian-size.data] _____________________

filename = 'err-endian-size.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-endian-size.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: invalid endian immediate at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
___________________ test_datafiles[err-incomplete-lddw.data] ___________________

filename = 'err-incomplete-lddw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-incomplete-lddw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: incomplete lddw at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
__________________ test_datafiles[err-incomplete-lddw2.data] ___________________

filename = 'err-incomplete-lddw2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-incomplete-lddw2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: incomplete lddw at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
____________________ test_datafiles[err-infinite-loop.data] ____________________

filename = 'err-infinite-loop.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-infinite-loop.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: infinite loop at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
___________________ test_datafiles[err-invalid-reg-dst.data] ___________________

filename = 'err-invalid-reg-dst.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-invalid-reg-dst.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: invalid destination register at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
___________________ test_datafiles[err-invalid-reg-src.data] ___________________

filename = 'err-invalid-reg-src.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-invalid-reg-src.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: invalid source register at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
______________________ test_datafiles[err-jmp-lddw.data] _______________________

filename = 'err-jmp-lddw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-jmp-lddw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: jump to middle of lddw at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
_______________________ test_datafiles[err-jmp-out.data] _______________________

filename = 'err-jmp-out.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-jmp-out.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: jump out of bounds at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
__________________ test_datafiles[err-lddw-invalid-src.data] ___________________

filename = 'err-lddw-invalid-src.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-lddw-invalid-src.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: invalid source register for LDDW at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
______________________ test_datafiles[err-stack-oob.data] ______________________

filename = 'err-stack-oob.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-stack-oob.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
>               raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
E               AssertionError: Expected error matching 'ebpf error: out of bounds memory store at PC 0, addr .*, size 1', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:64: AssertionError
________________ test_datafiles[err-too-many-instructions.data] ________________

filename = 'err-too-many-instructions.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-too-many-instructions.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: too many instructions (max 65536)', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
___________________ test_datafiles[err-unknown-opcode.data] ____________________

filename = 'err-unknown-opcode.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'err-unknown-opcode.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: unknown opcode 0x06 at PC 0', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
______________________ test_datafiles[exit-not-last.data] ______________________

filename = 'exit-not-last.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'exit-not-last.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[exit.data] ___________________________

filename = 'exit.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'exit.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________________ test_datafiles[ja.data] ____________________________

filename = 'ja.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ja.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jeq-imm.data] _________________________

filename = 'jeq-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jeq-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jeq-reg.data] _________________________

filename = 'jeq-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jeq-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jge-imm.data] _________________________

filename = 'jge-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jge-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jgt-imm.data] _________________________

filename = 'jgt-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jgt-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jgt-reg.data] _________________________

filename = 'jgt-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jgt-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_______________________ test_datafiles[jit-bounce.data] ________________________

filename = 'jit-bounce.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jit-bounce.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jle-imm.data] _________________________

filename = 'jle-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jle-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jle-reg.data] _________________________

filename = 'jle-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jle-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jlt-imm.data] _________________________

filename = 'jlt-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jlt-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jlt-reg.data] _________________________

filename = 'jlt-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jlt-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[jne-reg.data] _________________________

filename = 'jne-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jne-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jset-imm.data] _________________________

filename = 'jset-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jset-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jset-reg.data] _________________________

filename = 'jset-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jset-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jsge-imm.data] _________________________

filename = 'jsge-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsge-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jsge-reg.data] _________________________

filename = 'jsge-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsge-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jsgt-imm.data] _________________________

filename = 'jsgt-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsgt-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jsgt-reg.data] _________________________

filename = 'jsgt-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsgt-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jsle-imm.data] _________________________

filename = 'jsle-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsle-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jsle-reg.data] _________________________

filename = 'jsle-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jsle-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jslt-imm.data] _________________________

filename = 'jslt-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jslt-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[jslt-reg.data] _________________________

filename = 'jslt-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'jslt-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[lddw.data] ___________________________

filename = 'lddw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'lddw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[lddw2.data] __________________________

filename = 'lddw2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'lddw2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[ldxb-all.data] _________________________

filename = 'ldxb-all.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxb-all.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[ldxb.data] ___________________________

filename = 'ldxb.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxb.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[ldxdw.data] __________________________

filename = 'ldxdw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxdw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[ldxh-all.data] _________________________

filename = 'ldxh-all.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxh-all.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[ldxh-all2.data] ________________________

filename = 'ldxh-all2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxh-all2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
______________________ test_datafiles[ldxh-same-reg.data] ______________________

filename = 'ldxh-same-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxh-same-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[ldxh.data] ___________________________

filename = 'ldxh.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxh.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[ldxw-all.data] _________________________

filename = 'ldxw-all.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxw-all.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[ldxw.data] ___________________________

filename = 'ldxw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'ldxw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[le16.data] ___________________________

filename = 'le16.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'le16.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[le32.data] ___________________________

filename = 'le32.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'le32.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[le64.data] ___________________________

filename = 'le64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'le64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[lsh-reg.data] _________________________

filename = 'lsh-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'lsh-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[mem-len.data] _________________________

filename = 'mem-len.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mem-len.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_____________________ test_datafiles[mod-by-zero-imm.data] _____________________

filename = 'mod-by-zero-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod-by-zero-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_____________________ test_datafiles[mod-by-zero-reg.data] _____________________

filename = 'mod-by-zero-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod-by-zero-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________________ test_datafiles[mod.data] ___________________________

filename = 'mod.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[mod32.data] __________________________

filename = 'mod32.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod32.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[mod64-by-zero-imm.data] ____________________

filename = 'mod64-by-zero-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod64-by-zero-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[mod64-by-zero-reg.data] ____________________

filename = 'mod64-by-zero-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod64-by-zero-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[mod64.data] __________________________

filename = 'mod64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mod64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________________ test_datafiles[mov.data] ___________________________

filename = 'mov.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mov.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[mov64-sign-extend.data] ____________________

filename = 'mov64-sign-extend.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mov64-sign-extend.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[mul-loop.data] _________________________

filename = 'mul-loop.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul-loop.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[mul32-imm.data] ________________________

filename = 'mul32-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul32-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________ test_datafiles[mul32-reg-overflow.data] ____________________

filename = 'mul32-reg-overflow.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul32-reg-overflow.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[mul32-reg.data] ________________________

filename = 'mul32-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul32-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[mul64-imm.data] ________________________

filename = 'mul64-imm.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul64-imm.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[mul64-reg.data] ________________________

filename = 'mul64-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'mul64-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________________ test_datafiles[neg.data] ___________________________

filename = 'neg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'neg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[neg64.data] __________________________

filename = 'neg64.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'neg64.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[prime.data] __________________________

filename = 'prime.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'prime.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[reload.data] __________________________

filename = 'reload.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'reload.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
>               raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
E               AssertionError: Expected error 'Failed to load code: code has already been loaded into this VM. Use ebpf_unload_code() if you need to reuse this VM', got "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:61: AssertionError
_________________________ test_datafiles[rsh-reg.data] _________________________

filename = 'rsh-reg.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'rsh-reg.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[rsh32.data] __________________________

filename = 'rsh32.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'rsh32.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[stack.data] __________________________

filename = 'stack.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stack.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[stack2.data] __________________________

filename = 'stack2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stack2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[stack3.data] __________________________

filename = 'stack3.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stack3.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________________ test_datafiles[stb.data] ___________________________

filename = 'stb.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stb.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[stdw.data] ___________________________

filename = 'stdw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stdw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________________ test_datafiles[sth.data] ___________________________

filename = 'sth.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'sth.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
______________________ test_datafiles[string-stack.data] _______________________

filename = 'string-stack.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'string-stack.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________________ test_datafiles[stw.data] ___________________________

filename = 'stw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[stxb-all.data] _________________________

filename = 'stxb-all.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxb-all.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________________ test_datafiles[stxb-all2.data] ________________________

filename = 'stxb-all2.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxb-all2.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_______________________ test_datafiles[stxb-chain.data] ________________________

filename = 'stxb-chain.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxb-chain.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[stxb.data] ___________________________

filename = 'stxb.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxb.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[stxdw.data] __________________________

filename = 'stxdw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxdw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[stxh.data] ___________________________

filename = 'stxh.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxh.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
__________________________ test_datafiles[stxw.data] ___________________________

filename = 'stxw.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'stxw.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_________________________ test_datafiles[subnet.data] __________________________

filename = 'subnet.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'subnet.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[tcp-port-80/match.data] ____________________

filename = 'tcp-port-80/match.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-port-80/match.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
______________ test_datafiles[tcp-port-80/nomatch-ethertype.data] ______________

filename = 'tcp-port-80/nomatch-ethertype.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-port-80/nomatch-ethertype.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
________________ test_datafiles[tcp-port-80/nomatch-proto.data] ________________

filename = 'tcp-port-80/nomatch-proto.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-port-80/nomatch-proto.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
___________________ test_datafiles[tcp-port-80/nomatch.data] ___________________

filename = 'tcp-port-80/nomatch.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-port-80/nomatch.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
_____________________ test_datafiles[tcp-sack/match.data] ______________________

filename = 'tcp-sack/match.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-sack/match.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
____________________ test_datafiles[tcp-sack/nomatch.data] _____________________

filename = 'tcp-sack/nomatch.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'tcp-sack/nomatch.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
______________________ test_datafiles[unload_reload.data] ______________________

filename = 'unload_reload.data'

    @pytest.mark.parametrize("filename", testdata.list_files(_test_data_dir))
    def test_datafiles(filename):
        # This is now a regular test function that will be called once for each filename
>       check_datafile(filename)

test/test_framework/test_vm.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filename = 'unload_reload.data'

    def check_datafile(filename):
        """
        Given assembly source code and an expected result, run the eBPF program and
        verify that the result matches.
        """
        data = testdata.read(_test_data_dir, filename)
        if 'asm' not in data and 'raw' not in data:
            raise SkipTest("no asm or raw section in datafile")
        if 'result' not in data and 'error' not in data and 'error pattern' not in data:
            raise SkipTest("no result or error section in datafile")
        if not os.path.exists(VM):
            raise SkipTest("VM not found: ", VM)
    
        if 'raw' in data:
            code = b''.join(struct.pack("=Q", x) for x in data['raw'])
        else:
            code = ubpf.assembler.assemble(data['asm'])
    
        memfile = None
    
        cmd = [VM]
        if 'mem' in data:
            memfile = tempfile.NamedTemporaryFile()
            memfile.write(data['mem'])
            memfile.flush()
            cmd.extend(['-m', memfile.name])
        if 'reload' in data:
            cmd.extend(['-R'])
        if 'unload' in data:
            cmd.extend(['-U'])
    
        cmd.append('-')
    
        # print(cmd)
        vm = Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=PIPE)
    
        stdout, stderr = vm.communicate(code)
        stdout = stdout.decode("utf-8")
        stderr = stderr.decode("utf-8")
        stderr = stderr.strip()
    
        if memfile:
            memfile.close()
    
        if 'error' in data:
            if data['error'] != stderr:
                raise AssertionError("Expected error %r, got %r" % (data['error'], stderr))
        elif 'error pattern' in data:
            if not re.search(data['error pattern'], stderr):
                raise AssertionError("Expected error matching %r, got %r" % (data['error pattern'], stderr))
        else:
            if stderr:
>               raise AssertionError("Unexpected error %r" % stderr)
E               AssertionError: Unexpected error "arm-binfmt-P: Could not open '/lib/ld-linux.so.3': No such file or directory"

test/test_framework/test_vm.py:67: AssertionError
=============================== warnings summary ===============================
test/lib/python3.8/site-packages/nose/importer.py:12
  /home/yunwei/libebpf/test/lib/python3.8/site-packages/nose/importer.py:12: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses
    from imp import find_module, load_module, acquire_lock, release_lock

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED test/test_framework/test_jit.py::test_datafiles[add.data] - AssertionE...
FAILED test/test_framework/test_jit.py::test_datafiles[add64.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[alu-arith.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[alu-bit.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[alu64-arith.data] - As...
FAILED test/test_framework/test_jit.py::test_datafiles[alu64-bit.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[arsh-reg.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[arsh.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[arsh32-high-shift.data]
FAILED test/test_framework/test_jit.py::test_datafiles[arsh64.data] - Asserti...
FAILED test/test_framework/test_jit.py::test_datafiles[be16-high.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[be16.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[be32-high.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[be32.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[be64.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[call-memfrob.data] - A...
FAILED test/test_framework/test_jit.py::test_datafiles[call-save.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[call.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[call_unwind.data] - As...
FAILED test/test_framework/test_jit.py::test_datafiles[call_unwind_fail.data]
FAILED test/test_framework/test_jit.py::test_datafiles[div-by-zero-imm.data]
FAILED test/test_framework/test_jit.py::test_datafiles[div-by-zero-reg.data]
FAILED test/test_framework/test_jit.py::test_datafiles[div32-high-divisor.data]
FAILED test/test_framework/test_jit.py::test_datafiles[div32-imm.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[div32-reg.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[div64-by-zero-imm.data]
FAILED test/test_framework/test_jit.py::test_datafiles[div64-by-zero-reg.data]
FAILED test/test_framework/test_jit.py::test_datafiles[div64-imm.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[div64-negative-imm.data]
FAILED test/test_framework/test_jit.py::test_datafiles[div64-negative-reg.data]
FAILED test/test_framework/test_jit.py::test_datafiles[div64-reg.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[early-exit.data] - Ass...
FAILED test/test_framework/test_jit.py::test_datafiles[err-call-bad-imm.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-call-unreg.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-endian-size.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-incomplete-lddw.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-incomplete-lddw2.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-infinite-loop.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-invalid-reg-dst.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-invalid-reg-src.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-jmp-lddw.data] - A...
FAILED test/test_framework/test_jit.py::test_datafiles[err-jmp-out.data] - As...
FAILED test/test_framework/test_jit.py::test_datafiles[err-lddw-invalid-src.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-too-many-instructions.data]
FAILED test/test_framework/test_jit.py::test_datafiles[err-unknown-opcode.data]
FAILED test/test_framework/test_jit.py::test_datafiles[exit-not-last.data] - ...
FAILED test/test_framework/test_jit.py::test_datafiles[exit.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[ja.data] - AssertionEr...
FAILED test/test_framework/test_jit.py::test_datafiles[jeq-imm.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jeq-reg.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jge-imm.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jgt-imm.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jgt-reg.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jit-bounce.data] - Ass...
FAILED test/test_framework/test_jit.py::test_datafiles[jle-imm.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jle-reg.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jlt-imm.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jlt-reg.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jne-reg.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[jset-imm.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[jset-reg.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[jsge-imm.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[jsge-reg.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[jsgt-imm.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[jsgt-reg.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[jsle-imm.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[jsle-reg.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[jslt-imm.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[jslt-reg.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[lddw.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[lddw2.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[ldxb-all.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[ldxb.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[ldxdw.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[ldxh-all.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[ldxh-all2.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[ldxh-same-reg.data] - ...
FAILED test/test_framework/test_jit.py::test_datafiles[ldxh.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[ldxw-all.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[ldxw.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[le16.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[le32.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[le64.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[lsh-reg.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[mem-len.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[mod-by-zero-imm.data]
FAILED test/test_framework/test_jit.py::test_datafiles[mod-by-zero-reg.data]
FAILED test/test_framework/test_jit.py::test_datafiles[mod.data] - AssertionE...
FAILED test/test_framework/test_jit.py::test_datafiles[mod32.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[mod64-by-zero-imm.data]
FAILED test/test_framework/test_jit.py::test_datafiles[mod64-by-zero-reg.data]
FAILED test/test_framework/test_jit.py::test_datafiles[mod64.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[mov.data] - AssertionE...
FAILED test/test_framework/test_jit.py::test_datafiles[mov64-sign-extend.data]
FAILED test/test_framework/test_jit.py::test_datafiles[mul-loop.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[mul32-imm.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[mul32-reg-overflow.data]
FAILED test/test_framework/test_jit.py::test_datafiles[mul32-reg.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[mul64-imm.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[mul64-reg.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[neg.data] - AssertionE...
FAILED test/test_framework/test_jit.py::test_datafiles[neg64.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[prime.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[reload.data] - Asserti...
FAILED test/test_framework/test_jit.py::test_datafiles[rsh-reg.data] - Assert...
FAILED test/test_framework/test_jit.py::test_datafiles[rsh32.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[stack.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[stack2.data] - Asserti...
FAILED test/test_framework/test_jit.py::test_datafiles[stack3.data] - Asserti...
FAILED test/test_framework/test_jit.py::test_datafiles[stb.data] - AssertionE...
FAILED test/test_framework/test_jit.py::test_datafiles[stdw.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[sth.data] - AssertionE...
FAILED test/test_framework/test_jit.py::test_datafiles[string-stack.data] - A...
FAILED test/test_framework/test_jit.py::test_datafiles[stw.data] - AssertionE...
FAILED test/test_framework/test_jit.py::test_datafiles[stxb-all.data] - Asser...
FAILED test/test_framework/test_jit.py::test_datafiles[stxb-all2.data] - Asse...
FAILED test/test_framework/test_jit.py::test_datafiles[stxb-chain.data] - Ass...
FAILED test/test_framework/test_jit.py::test_datafiles[stxb.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[stxdw.data] - Assertio...
FAILED test/test_framework/test_jit.py::test_datafiles[stxh.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[stxw.data] - Assertion...
FAILED test/test_framework/test_jit.py::test_datafiles[subnet.data] - Asserti...
FAILED test/test_framework/test_jit.py::test_datafiles[tcp-port-80/match.data]
FAILED test/test_framework/test_jit.py::test_datafiles[tcp-port-80/nomatch-ethertype.data]
FAILED test/test_framework/test_jit.py::test_datafiles[tcp-port-80/nomatch-proto.data]
FAILED test/test_framework/test_jit.py::test_datafiles[tcp-port-80/nomatch.data]
FAILED test/test_framework/test_jit.py::test_datafiles[tcp-sack/match.data]
FAILED test/test_framework/test_jit.py::test_datafiles[tcp-sack/nomatch.data]
FAILED test/test_framework/test_jit.py::test_datafiles[unload_reload.data] - ...
FAILED test/test_framework/test_vm.py::test_datafiles[add.data] - AssertionEr...
FAILED test/test_framework/test_vm.py::test_datafiles[add64.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[alu-arith.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[alu-bit.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[alu64-arith.data] - Ass...
FAILED test/test_framework/test_vm.py::test_datafiles[alu64-bit.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[arsh-reg.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[arsh.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[arsh32-high-shift.data]
FAILED test/test_framework/test_vm.py::test_datafiles[arsh64.data] - Assertio...
FAILED test/test_framework/test_vm.py::test_datafiles[be16-high.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[be16.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[be32-high.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[be32.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[be64.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[call-memfrob.data] - As...
FAILED test/test_framework/test_vm.py::test_datafiles[call-save.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[call.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[call_unwind.data] - Ass...
FAILED test/test_framework/test_vm.py::test_datafiles[call_unwind_fail.data]
FAILED test/test_framework/test_vm.py::test_datafiles[div-by-zero-imm.data]
FAILED test/test_framework/test_vm.py::test_datafiles[div-by-zero-reg.data]
FAILED test/test_framework/test_vm.py::test_datafiles[div32-high-divisor.data]
FAILED test/test_framework/test_vm.py::test_datafiles[div32-imm.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[div32-reg.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[div64-by-zero-imm.data]
FAILED test/test_framework/test_vm.py::test_datafiles[div64-by-zero-reg.data]
FAILED test/test_framework/test_vm.py::test_datafiles[div64-imm.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[div64-negative-imm.data]
FAILED test/test_framework/test_vm.py::test_datafiles[div64-negative-reg.data]
FAILED test/test_framework/test_vm.py::test_datafiles[div64-reg.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[early-exit.data] - Asse...
FAILED test/test_framework/test_vm.py::test_datafiles[err-call-bad-imm.data]
FAILED test/test_framework/test_vm.py::test_datafiles[err-call-unreg.data] - ...
FAILED test/test_framework/test_vm.py::test_datafiles[err-endian-size.data]
FAILED test/test_framework/test_vm.py::test_datafiles[err-incomplete-lddw.data]
FAILED test/test_framework/test_vm.py::test_datafiles[err-incomplete-lddw2.data]
FAILED test/test_framework/test_vm.py::test_datafiles[err-infinite-loop.data]
FAILED test/test_framework/test_vm.py::test_datafiles[err-invalid-reg-dst.data]
FAILED test/test_framework/test_vm.py::test_datafiles[err-invalid-reg-src.data]
FAILED test/test_framework/test_vm.py::test_datafiles[err-jmp-lddw.data] - As...
FAILED test/test_framework/test_vm.py::test_datafiles[err-jmp-out.data] - Ass...
FAILED test/test_framework/test_vm.py::test_datafiles[err-lddw-invalid-src.data]
FAILED test/test_framework/test_vm.py::test_datafiles[err-stack-oob.data] - A...
FAILED test/test_framework/test_vm.py::test_datafiles[err-too-many-instructions.data]
FAILED test/test_framework/test_vm.py::test_datafiles[err-unknown-opcode.data]
FAILED test/test_framework/test_vm.py::test_datafiles[exit-not-last.data] - A...
FAILED test/test_framework/test_vm.py::test_datafiles[exit.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[ja.data] - AssertionErr...
FAILED test/test_framework/test_vm.py::test_datafiles[jeq-imm.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jeq-reg.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jge-imm.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jgt-imm.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jgt-reg.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jit-bounce.data] - Asse...
FAILED test/test_framework/test_vm.py::test_datafiles[jle-imm.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jle-reg.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jlt-imm.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jlt-reg.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jne-reg.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[jset-imm.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[jset-reg.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[jsge-imm.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[jsge-reg.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[jsgt-imm.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[jsgt-reg.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[jsle-imm.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[jsle-reg.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[jslt-imm.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[jslt-reg.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[lddw.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[lddw2.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[ldxb-all.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[ldxb.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[ldxdw.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[ldxh-all.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[ldxh-all2.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[ldxh-same-reg.data] - A...
FAILED test/test_framework/test_vm.py::test_datafiles[ldxh.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[ldxw-all.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[ldxw.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[le16.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[le32.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[le64.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[lsh-reg.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[mem-len.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[mod-by-zero-imm.data]
FAILED test/test_framework/test_vm.py::test_datafiles[mod-by-zero-reg.data]
FAILED test/test_framework/test_vm.py::test_datafiles[mod.data] - AssertionEr...
FAILED test/test_framework/test_vm.py::test_datafiles[mod32.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[mod64-by-zero-imm.data]
FAILED test/test_framework/test_vm.py::test_datafiles[mod64-by-zero-reg.data]
FAILED test/test_framework/test_vm.py::test_datafiles[mod64.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[mov.data] - AssertionEr...
FAILED test/test_framework/test_vm.py::test_datafiles[mov64-sign-extend.data]
FAILED test/test_framework/test_vm.py::test_datafiles[mul-loop.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[mul32-imm.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[mul32-reg-overflow.data]
FAILED test/test_framework/test_vm.py::test_datafiles[mul32-reg.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[mul64-imm.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[mul64-reg.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[neg.data] - AssertionEr...
FAILED test/test_framework/test_vm.py::test_datafiles[neg64.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[prime.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[reload.data] - Assertio...
FAILED test/test_framework/test_vm.py::test_datafiles[rsh-reg.data] - Asserti...
FAILED test/test_framework/test_vm.py::test_datafiles[rsh32.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[stack.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[stack2.data] - Assertio...
FAILED test/test_framework/test_vm.py::test_datafiles[stack3.data] - Assertio...
FAILED test/test_framework/test_vm.py::test_datafiles[stb.data] - AssertionEr...
FAILED test/test_framework/test_vm.py::test_datafiles[stdw.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[sth.data] - AssertionEr...
FAILED test/test_framework/test_vm.py::test_datafiles[string-stack.data] - As...
FAILED test/test_framework/test_vm.py::test_datafiles[stw.data] - AssertionEr...
FAILED test/test_framework/test_vm.py::test_datafiles[stxb-all.data] - Assert...
FAILED test/test_framework/test_vm.py::test_datafiles[stxb-all2.data] - Asser...
FAILED test/test_framework/test_vm.py::test_datafiles[stxb-chain.data] - Asse...
FAILED test/test_framework/test_vm.py::test_datafiles[stxb.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[stxdw.data] - Assertion...
FAILED test/test_framework/test_vm.py::test_datafiles[stxh.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[stxw.data] - AssertionE...
FAILED test/test_framework/test_vm.py::test_datafiles[subnet.data] - Assertio...
FAILED test/test_framework/test_vm.py::test_datafiles[tcp-port-80/match.data]
FAILED test/test_framework/test_vm.py::test_datafiles[tcp-port-80/nomatch-ethertype.data]
FAILED test/test_framework/test_vm.py::test_datafiles[tcp-port-80/nomatch-proto.data]
FAILED test/test_framework/test_vm.py::test_datafiles[tcp-port-80/nomatch.data]
FAILED test/test_framework/test_vm.py::test_datafiles[tcp-sack/match.data] - ...
FAILED test/test_framework/test_vm.py::test_datafiles[tcp-sack/nomatch.data]
FAILED test/test_framework/test_vm.py::test_datafiles[unload_reload.data] - A...
=========== 259 failed, 144 passed, 382 skipped, 1 warning in 14.39s ===========
